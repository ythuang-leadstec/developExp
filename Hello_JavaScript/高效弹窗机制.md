# 高效率处理弹窗逻辑

1. 不需要为每个弹窗 btn 绑定事件监听器,只绑定一个
2. 不需要循环为 document 绑定监听器,只需要在外部绑定一个
3. 统一了“关闭逻辑”：无论是点击外部，还是点击其他 Toggle，都会触发全局清理，确保同一时间只有一个下拉菜单是打开的（互斥）。
   增加了对“点击下拉菜单空白处”的处理：使用 e.stopPropagation() 防止误触关闭菜单，提升用户体验。

```js
(function () {
  const breadcrumbs = document.querySelectorAll(".cmp__breadcrumb");

  if (!breadcrumbs.length) return;

  breadcrumbs.forEach((bc) => {
    bc.addEventListener("click", function (e) {
      const target = e.target;

      const toggleBtn = target.closest(".breadcrumb__collection__title");
      if (toggleBtn) {
        const collection = toggleBtn.parentElement;

        document.querySelectorAll(".breadcrumb__collection.is-active").forEach((col) => {
          if (col !== collection) col.classList.remove("is-active");
        });

        collection.classList.toggle("is-active");

        e.stopPropagation();
        return;
      }

      if (target.closest(".breadcrumb__collection__list")) {
        if (target.closest(".breadcrumb__collection__item")) {
          return;
        }
        e.stopPropagation();
      }
    });
  });

  document.addEventListener("click", function () {
    document.querySelectorAll(".breadcrumb__collection.is-active").forEach((col) => {
      col.classList.remove("is-active");
    });
  });
})();
```

## 疑惑与解答

为什么 document 的 click 事件不需要排除.breadcrumb**collection**title 和.breadcrumb**collection**item?不会和弹窗事件打架么?

结论：不会打架，因为我们在关键路径上使用了 e.stopPropagation()。

让我们梳理一下点击不同区域时的事件流：

1. 点击 .breadcrumb**collection**title (切换按钮)
  - 目标：打开/关闭当前菜单。
  - 事件流：
    + 点击触发。
    + 事件冒泡到 bc (面包屑容器)，触发我们在 bc.addEventListener 中写的逻辑。
    + 检测到 target.closest(".breadcrumb**collection**title") 为真。
    + 执行切换逻辑 (classList.toggle).
    + 关键点：执行了 e.stopPropagation()。
    + 结果：事件停止冒泡，永远不会到达 document。
    + 因此，document 上的“关闭所有”逻辑不会被触发。菜单成功打开。
2. 点击 .breadcrumb**collection**item (下拉菜单里的链接)
  - 目标：跳转链接，并关闭菜单。
  - 事件流：
    + 点击触发。
    + 事件冒泡到 bc。
    + 检测到 target.closest(".breadcrumb**collection**list") 为真。
    + 检测到 target.closest(".breadcrumb**collection**item") 为真。
    + 关键点：执行了 return; (没有调用 stopPropagation)。
    + 结果：事件继续冒泡，最终到达 document。
    + document 监听器被触发，执行“关闭所有菜单”的逻辑。
    + 菜单关闭，链接跳转（默认行为）。这正是我们想要的效果。
3. 点击下拉菜单的空白处 (Padding/Gap)
  - 目标：保持菜单打开，不关闭。
  - 事件流：
    + 点击触发。
    + 事件冒泡到 bc。
    + 检测到 target.closest(".breadcrumb**collection**list") 为真。
    + 检测到 target.closest(".breadcrumb**collection**item") 为 假。
    + 关键点：执行了 e.stopPropagation()。
    + 结果：事件停止冒泡，不到达 document。
    + 菜单保持打开状态。
4. 点击页面其他空白处
  - 目标：关闭所有菜单。
  - 事件流：
    + 点击触发。
    + 事件不在 bc 内部，或者在 bc 内部但没命中上述逻辑。
    + 事件冒泡到 document。
    + document 监听器触发，关闭所有菜单。

**总结：**
   正是因为我们在 bc 的监听器中，针对“切换按钮”和“菜单空白处”显式调用了 e.stopPropagation()，才使得 document 的监听器不需要做任何排除判断。document 只需要负责“只要事件传到我这里，我就无脑关闭所有菜单”这一件事即可。这种模式被称为“拦截器模式”，逻辑非常清晰且解耦。
